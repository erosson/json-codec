import * as D from './decode'

test("decode string", () => {
    expect(D.decodeValue(D.string, "foo")).toBe("foo")
    expect(() => D.decodeValue(D.string, 3)).toThrow("Expecting a STRING")
})
test("decode number", () => {
    expect(D.decodeValue(D.number, 3)).toBe(3)
    expect(D.decodeValue(D.number, 0)).toBe(0)
    expect(D.decodeValue(D.number, NaN)).toBe(NaN)
    expect(() => D.decodeValue(D.number, "foo")).toThrow("Expecting a NUMBER")
})
test("decode boolean", () => {
    expect(D.decodeValue(D.boolean, true)).toBe(true)
    expect(D.decodeValue(D.boolean, false)).toBe(false)
    expect(() => D.decodeValue(D.boolean, null)).toThrow("Expecting a BOOLEAN")
})
test("decode null", () => {
    expect(D.decodeValue(D.null_, null)).toBe(null)
    expect(() => D.decodeValue(D.null_, false)).toThrow("Expecting a NULL")
})
test("decode nullable", () => {
    expect(D.decodeValue(D.nullable(D.number), null)).toBe(null)
    expect(D.decodeValue(D.nullable(D.number), 3)).toBe(3)
    expect(() => D.decodeValue(D.nullable(D.number), "three")).toThrow("Expecting a NULL")
})
test("decode array", () => {
    expect(D.decodeValue(D.array(D.number), [])).toEqual([])
    expect(D.decodeValue(D.array(D.number), [3])).toEqual([3])
    expect(D.decodeValue(D.array(D.number), [3, 4, 5])).toEqual([3, 4, 5])
    expect(D.decodeValue(D.array(D.nullable(D.number)), [3, 4, 5, null])).toEqual([3, 4, 5, null])
    expect(() => D.decodeValue(D.array(D.number), "three")).toThrow("Expecting an ARRAY")
    expect(() => D.decodeValue(D.array(D.number), ["three"])).toThrow("Expecting a NUMBER")
    expect(() => D.decodeValue(D.array(D.number), [3, 4, "five"])).toThrow("Expecting a NUMBER")
})
test("decode dict", () => {
    expect(D.decodeValue(D.dict(D.number), {})).toEqual({})
    expect(D.decodeValue(D.dict(D.number), { three: 3 })).toEqual({ three: 3 })
    expect(D.decodeValue(D.dict(D.number), { three: 3, four: 4 })).toEqual({ three: 3, four: 4 })
    expect(D.decodeValue(D.dict(D.nullable(D.number)), { three: 3, four: null })).toEqual({ three: 3, four: null })
    expect(() => D.decodeValue(D.dict(D.number), "three")).toThrow("Expecting an OBJECT")
    expect(() => D.decodeValue(D.dict(D.number), { three: "three" })).toThrow("Expecting a NUMBER")
    expect(() => D.decodeValue(D.dict(D.number), { three: 3, four: "four" })).toThrow("Expecting a NUMBER")
})
test("decode field", () => {
    expect(D.decodeValue(D.field("key", D.number), { key: 99 })).toBe(99)
    expect(() => D.decodeValue(D.field("key", D.number), 99)).toThrow("Expecting an OBJECT")
    expect(() => D.decodeValue(D.field("key", D.number), [99])).toThrow("Expecting an OBJECT")
    expect(() => D.decodeValue(D.field("key", D.number), { key: "oof" })).toThrow("Expecting a NUMBER")
    expect(() => D.decodeValue(D.field("key", D.number), {})).toThrow("Missing key")
    expect(D.field("key", D.number).decoderFn({ key: "oof" })).toMatchObject({ error: { path: ["key"] } })
    expect(D.field("key", D.field("two", D.number)).decoderFn({ key: { two: "oof" } })).toMatchObject({ error: { path: ["key", "two"] } })
})
test("decode index", () => {
    expect(D.decodeValue(D.index(0, D.number), [10, 11, 12])).toBe(10)
    expect(D.decodeValue(D.index(1, D.number), [10, 11, 12])).toBe(11)
    expect(() => D.decodeValue(D.index(0, D.number), 10)).toThrow("Expecting an ARRAY")
    expect(() => D.decodeValue(D.index(0, D.number), { key: 10 })).toThrow("Expecting an ARRAY")
    expect(() => D.decodeValue(D.index(0, D.number), ["oof"])).toThrow("Expecting a NUMBER")
    expect(() => D.decodeValue(D.index(0, D.number), [])).toThrow("Missing key")
    expect(D.index(0, D.number).decoderFn(["oof"])).toMatchObject({ error: { path: [0] } })
    expect(D.index(0, D.index(1, D.number)).decoderFn([["oof", "oof"]])).toMatchObject({ error: { path: [0, 1] } })
})
test("decode get", () => {
    expect(D.decodeValue(D.get(0, D.number), [10, 11, 12])).toBe(10)
    expect(D.decodeValue(D.field("key", D.number), { key: 99 })).toBe(99)
    expect(() => D.decodeValue(D.get(0, D.number), { key: 10 })).toThrow("Expecting an ARRAY")
    expect(() => D.decodeValue(D.get("key", D.number), [99])).toThrow("Expecting an OBJECT")
    expect(D.get(0, D.number).decoderFn(["oof"])).toMatchObject({ error: { path: [0] } })
})
test("decode at", () => {
    expect(D.decodeValue(D.at([], D.number), 10)).toBe(10)
    expect(D.decodeValue(D.at([0], D.number), [10])).toBe(10)
    expect(D.decodeValue(D.at([0, 0], D.number), [[10]])).toBe(10)
    expect(D.decodeValue(D.at([1, 0], D.number), [11, [10]])).toBe(10)
    expect(D.decodeValue(D.at([1, 1], D.number), [11, [12, 10]])).toBe(10)
    expect(D.decodeValue(D.at([0, "key"], D.number), [{ key: 10 }])).toBe(10)
    expect(D.decodeValue(D.at(["key", 0], D.number), { key: [10] })).toBe(10)
    expect(() => D.decodeValue(D.at([], D.number), "ten")).toThrow("Expecting a NUMBER")
    expect(() => D.decodeValue(D.at([0], D.number), [])).toThrow("Missing key")
    expect(() => D.decodeValue(D.at([0], D.number), { key: "oof" })).toThrow("Expecting an ARRAY")
    expect(() => D.decodeValue(D.at(["key"], D.number), [10])).toThrow("Expecting an OBJECT")
    expect(D.at([0], D.number).decoderFn(["oof"])).toMatchObject({ error: { path: [0] } })
    expect(D.at(["key", 0], D.number).decoderFn({ key: ["oof"] })).toMatchObject({ error: { path: ["key", 0] } })
    expect(D.at([0, "key"], D.number).decoderFn([{ key: "oof" }])).toMatchObject({ error: { path: [0, "key"] } })
    expect(D.at([0, "key", "oof"], D.number).decoderFn([{ key: 10 }])).toMatchObject({ error: { path: [0, "key"] } })
})