{"mappings":"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","sources":["src/index.ts","src/encode.ts","src/json.ts","src/decode.ts"],"sourcesContent":["import * as E from './encode'\nexport const Encode = E\nexport * from './json'\nexport * from './decode'","/**\n * Turn Typescript values into JSON values.\n * \n * `JSON.stringify` does most of this for us in Typescript, so this module is\n * much smaller than the Elm equivalent.\n */\nimport { Value } from './json'\n\n/**\n * Decode a date as milliseconds since the unix epoch.\n * \n *     import * as Encode from './encode'\n * \n *     const now = new Date()\n *     const encoded = Encode.date(now)\n *     date.decodeValue(encoded) === now\n */\nexport function date(value: Date): Value {\n    return value.getTime()\n}","/**\n * Represents an undecoded, non-validated JSON value.\n */\nexport type Value\n    = string\n    | number\n    | boolean\n    | null\n    | Value[]\n    | { [k: string]: Value }\n\n/**\n * @see Value\n */\nexport type JSON = Value","/**\n * Turn JSON values into typed, validated Typescript values.\n * \n * Based on Elm's `Json.Decode` library. Documentation text is almost entirely stolen from there.\n * \n * Definitely check out the Elm to JSON decoders to get a feel for how this library works!\n * https://guide.elm-lang.org/effects/json.html\n */\nimport { Value } from './json'\n\ntype FieldError = { decodeError: 'field', path: (string | number)[], field: string, error: DecodeError }\ntype IndexError = { decodeError: 'index', path: (string | number)[], index: number, error: DecodeError }\ntype OneOfError = { decodeError: 'oneOf', path: (string | number)[], errors: DecodeError[] }\ntype FailureError = { decodeError: 'failure', path: (string | number)[], message: string, value: Value }\ntype DecodeError\n    = FieldError\n    | IndexError\n    | OneOfError\n    | FailureError\n\nconst error = {\n    field(field: string, error: DecodeError): DecodeErr {\n        return err({ decodeError: 'field', path: [], field, error })\n    },\n    index(index: number, error: DecodeError): DecodeErr {\n        return err({ decodeError: 'index', path: [], index, error })\n    },\n    oneOf(errors: DecodeError[]): DecodeErr {\n        return err({ decodeError: 'oneOf', path: [], errors })\n    },\n    failure(message: string, value: Value): DecodeErr {\n        return err({ decodeError: 'failure', path: [], message, value })\n    },\n    expecting(type_: string, value: Value): DecodeErr {\n        return err({ decodeError: 'failure', path: [], message: `Expecting ${type_}`, value })\n    },\n    missing(key: string | number, value: Value): DecodeErr {\n        return err({ decodeError: 'failure', path: [], message: `Missing key: ${JSON.stringify(key)}`, value })\n    },\n}\n\ntype Err<E> = { success: false, error: E }\ntype Ok<V> = { success: true, value: V }\ntype Result<E, V> = Err<E> | Ok<V>\n\ntype DecodeErr = Err<DecodeError>\ntype DecodeResult<V> = Result<DecodeError, V>\n\nfunction ok<V>(value: V): Ok<V> {\n    return { success: true, value }\n}\nfunction err(error: DecodeError): DecodeErr {\n    return { success: false, error }\n}\n\n\n/**\n * A value that knows how to decode JSON values.\n * \n * Based on Elm's JSON decoders:\n * https://package.elm-lang.org/packages/elm/json/latest/Json.Decode\n */\nexport class Decoder<T> {\n    /**\n     * @hideconstructor\n     */\n    constructor(private decoderFn: (v: Value) => DecodeResult<T>) { }\n\n    /**\n     * Run a `Decoder` on some JSON `Value`. If you've already run `JSON.parse`, or\n     * otherwise have your JSON as an object instead of a string, use this.\n     * \n     *     number.decodeValue(4) // 4\n     *     number.decodeValue(\"four\") // throws ParseError\n     */\n    decodeValue(value: Value): T {\n        const res = this.decoderFn(value)\n        if (res.success) {\n            return res.value\n        }\n        throw new Error(JSON.stringify(res.error, null, 2))\n    }\n\n    /**\n     * Parse the given string into a JSON value and then run the Decoder on it.\n     * This will fail if the string is not well-formed JSON or if the Decoder\n     * fails for some reason.\n     * \n     *     number.decodeString(\"4\") // 4\n     *     number.decodeString(\"1 + 2\") // throws ParseError\n     */\n    decodeString(value: string): T {\n        return this.decodeValue(JSON.parse(value))\n    }\n\n    /**\n     * Transform a decoder. Maybe you just want to know the length of a string:\n     *     \n     *     const stringLength: Decoder<number> = string.map((s: string): number => s.length)\n     * \n     * It is often helpful to use `map` with `oneOf`.\n     * \n     * One change from Elm is our removal of `map2`, `map3`, etc. Use {@link combine}\n     * to merge multiple arguments before calling `map`. For example:\n     * \n     *     // an example with an object/fields\n     *     type Point3D = {x: number, y: number, z: number}\n     *     const point3d: Decoder<Point3D> = combine({\n     *       x: number.field('x'),\n     *       y: number.field('y'),\n     *       z: number.field('z'),\n     *     })\n     *     const sum: Decoder<number> = point3d.map(({x, y, z}) => x + y + z)\n     * \n     *     // an example with a tuple/array\n     *     type Point3D = [number, number, number]\n     *     const point3d: Decoder<Point3D> = combine([\n     *       number.index(0),\n     *       number.index(1),\n     *       number.field(2),\n     *     ])\n     *     const sum: Decoder<number> = point3d.map(([x, y, z]) => x + y + z)\n     */\n    map<V>(fn: (t: T) => V): Decoder<V> {\n        const d = this\n        return new Decoder((v) => {\n            const resA = d.decoderFn(v)\n            return resA.success\n                ? ok(fn(resA.value))\n                : resA\n        })\n    }\n\n    /**\n     * Create decoders that depend on previous results. If you are creating versioned data, you might do something like this:\n     *     \n     *     const info: Decoder<Info> = field(\"version\", number).andThen(infoHelp)\n     *     \n     *     function infoHelp(version: number): Decoder<Info> {\n     *       switch(version) {\n     *         case 4: return infoDecoder4\n     *         case 3: return infoDecoder3\n     *         default: return fail(`Trying to decode info, but version ${version} is not supported.`)\n     *       }\n     *     }\n     *     \n     *     // const infoDecoder4: Decoder<Info>\n     *     // const infoDecoder3: Decoder<Info>\n     * \n     * @param fn The function to run on the previous decoder's results. Returns another decoder, to run on the same JSON.\n     */\n    andThen<V>(fn: (t: T) => Decoder<V>): Decoder<V> {\n        const d = this\n        return new Decoder((v) => {\n            const resA = d.decoderFn(v)\n            return resA.success\n                ? fn(resA.value).decoderFn(v)\n                : resA\n        })\n    }\n\n    /**\n     * Merge two decoders as a union type.\n     * \n     *     string.union(boolean).decodeString(\"true\") // true: string | boolean\n     *     string.union(boolean).decodeString(\"42\") // throws ParseError\n     *     string.union(boolean).decodeString(\"3.14\") // throws ParseError\n     *     string.union(boolean).decodeString(\"\\\"hello\\\"\") // \"hello\": string | boolean\n     *     string.union(boolean).decodeString(\"{ \\\"hello\\\": 42}\") // throws ParseError\n     *     string.union(boolean).decodeString(\"null\") // throws ParseError\n     */\n    union<V>(b: Decoder<V>): Decoder<T | V> {\n        const a = this\n        return new Decoder(function union(v): DecodeResult<T | V> {\n            const ar = a.decoderFn(v)\n            if (ar.success) {\n                return ar\n            }\n            const br = b.decoderFn(v)\n            if (br.success) {\n                return br\n            }\n            return error.oneOf([ar.error, br.error])\n        })\n    }\n\n    /**\n     * A decoder whose type can also include null.\n     * \n     * `d.nullable()` is equivalent to `union(null_)`.\n     * \n     *     string.nullable().decodeString(\"true\") // throws ParseError\n     *     string.nullable().decodeString(\"42\") // throws ParseError\n     *     string.nullable().decodeString(\"3.14\") // throws ParseError\n     *     string.nullable().decodeString(\"\\\"hello\\\"\") // \"hello\": string | null\n     *     string.nullable().decodeString(\"{ \\\"hello\\\": 42}\") // throws ParseError\n     *     string.nullable().decodeString(\"null\") // null: string | null\n     * \n     * See also the {@link nullable} function (this is the `nullable` method)\n     */\n    nullable(): Decoder<T | null> {\n        return this.union(null_)\n    }\n\n    /**\n     * Helpful for dealing with optional fields. Here are a few slightly different examples:\n     * \n     *     number.maybe().decodeString(42) // 42\n     *     number.maybe().decodeString(\"oof\") // null\n     * \n     *     json = \"\"\"{ \"name\": \"tom\", \"age\": 42 }\"\"\"\n     *     \n     *     number.field(\"age\").maybe().decodeString(json) // 42\n     *     number.field(\"name\").maybe().decodeString(json) // null\n     *     number.field(\"height\").maybe().decodeString(json) // null\n     *     \n     *     number.maybe().field(\"age\").decodeString(json) // 42\n     *     number.maybe().field(\"name\").decodeString(json) // null\n     *     number.maybe().field(\"height\").decodeString(json) // throws ParseError\n     * \n     * Notice the last example! It is saying we must have a field named height and the content may be a float. There is no height field, so the decoder fails.\n     * \n     * Point is, maybe will make exactly what it contains conditional. For optional fields, this means you probably want it outside a use of field or at.\n     * \n     * By default, `maybe` returns null instead of errors. You can also have it return some other value:\n     * \n     *     number.maybe(-1).decodeString(42) // 42\n     *     number.maybe(-1).decodeString(\"oof\") // -1\n     */\n    maybe(): Decoder<T | null>\n    maybe<D>(default_: D): Decoder<T | D>\n    maybe(default_?: any): Decoder<T | any> {\n        return default_ === undefined ? maybe(this) : maybe(this, default_)\n    }\n\n    /**\n     * Decode a JSON array into a Typescript array.\n     * \n     *     number.array().decodeString(\"[1,2,3]\") // [1,2,3]\n     *     boolean.array().decodeString(\"[true,false])\" // [true, false]\n     * \n     * @param d The decoder used to decode each array element\n     */\n    array(): Decoder<T[]> {\n        const this_ = this\n        return new Decoder(function array(v) {\n            if (Array.isArray(v)) {\n                const items: DecodeResult<T>[] = v.map(this_.decoderFn)\n                const [errs, oks] = items.reduce(([errs, oks]: [[number, DecodeError][], T[]], res: DecodeResult<T>, index: number): [[number, DecodeError][], T[]] => {\n                    if (res.success) {\n                        oks.push(res.value)\n                    }\n                    else {\n                        errs.push([index, res.error])\n                    }\n                    return [errs, oks]\n                }, [[], []])\n                if (errs.length) {\n                    const [index, e] = errs[0]\n                    return error.index(index, e)\n                }\n                return ok(oks)\n            }\n            else {\n                return error.expecting('an ARRAY', v)\n            }\n        })\n    }\n\n    /**\n     * Decode a JSON object into a Typescript list of pairs.\n     * \n     *     number.keyValuePairs().decodeString(\"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\")\n     *     // [[\"alice\", 42], [\"bob\", 99]]\n     */\n    keyValuePairs(): Decoder<[string, T][]> {\n        const d = this\n        return new Decoder(function keyValuePairs(v) {\n            if (typeof v === 'object' && v !== null) {\n                const items: [string, DecodeResult<T>][] = Object.entries(v).map(([k, c]) => [k, d.decoderFn(c)])\n                const [errs, oks] = items.reduce(([errs, oks]: [[string, DecodeError][], [string, T][]], [key, res]: [string, DecodeResult<T>]): [[string, DecodeError][], [string, T][]] => {\n                    if (res.success) {\n                        oks.push([key, res.value])\n                    }\n                    else {\n                        errs.push([key, res.error])\n                    }\n                    return [errs, oks]\n                }, [[], []])\n                if (errs.length) {\n                    const [key, e] = errs[0]\n                    return error.field(key, e)\n                }\n                return ok(oks)\n            }\n            return error.expecting('an OBJECT', v)\n        })\n    }\n\n    /**\n     * Decode a JSON object into a Typescript dictionary.\n     * \n     *     number.dict().decodeString(\"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\")\n     *     // {\"alice\": 42, \"bob\": 99}\n     * \n     * @param d The decoder used to decode each object value\n     * \n     * See also the {@link dict} function (this is the `dict` method)\n     */\n    dict(): Decoder<{ [k: string]: T }> {\n        const d = this\n        return new Decoder(function dict(v) {\n            const entries = d.keyValuePairs().decoderFn(v)\n            return entries.success ? ok(Object.fromEntries(entries.value)) : entries\n        })\n    }\n\n    /**\n     * Decode a JSON object, requiring a particular field.\n     * \n     *     number.field(\"x\").decodeString(\"{ \\\"x\\\": 3 }\") // 3\n     *     number.field(\"x\").decodeString(\"{ \\\"x\\\": 3, \\\"y\\\": 4 }\") // 3\n     *     number.field(\"x\").decodeString(\"{ \\\"x\\\": true }\") // throws ParseError\n     *     number.field(\"x\").decodeString(\"{ \\\"y\\\": 4 }\") // throws ParseError\n     *     \n     *     string.field(\"name\").decodeString(\"{ \\\"name\\\": \\\"tom\\\" }\") // \"tom\"\n     * \n     * The object can have other fields. Lots of them! The only thing this decoder cares about is if `x` is present and that the value there is a `number`.\n     * \n     * Check out `map` to see how to decode multiple fields!\n     * \n     * @param key The field to be looked up\n     */\n    field(key: string): Decoder<T> {\n        const d = this\n        return new Decoder(function field(v) {\n            if (typeof v === 'object' && v !== null && !Array.isArray(v)) {\n                if (key in v) {\n                    const res = d.decoderFn(v[key])\n                    if (!res.success) {\n                        res.error.path = [key, ...res.error.path]\n                    }\n                    return res\n                }\n                return error.missing(key, v)\n            }\n            return error.expecting('an OBJECT', v)\n        })\n    }\n\n    /**\n     * Decode a JSON array, requiring a particular array index.\n     *     \n     *     const json = `[ \"alice\", \"bob\", \"chuck\" ]`\n     *     \n     *     string.index(0).decodeString(json) // \"alice\"\n     *     string.index(1).decodeString(json) // \"bob\"\n     *     string.index(2).decodeString(json) // \"chuck\"\n     *     string.index(3).decodeString(json) // throws ParseError\n     * \n     * @param key The array index to be looked up\n     */\n    index(i: number): Decoder<T> {\n        const d = this\n        return new Decoder(function index(v) {\n            if (Array.isArray(v)) {\n                if (i in v) {\n                    const res = d.decoderFn(v[i])\n                    if (!res.success) {\n                        res.error.path = [i, ...res.error.path]\n                    }\n                    return res\n                }\n                return error.missing(i, v)\n            }\n            return error.expecting('an ARRAY', v)\n        })\n    }\n\n    /**\n     * Decode a JSON object, requiring a particular field or array index.\n     * \n     * Combines `field()` and `index()`.\n     * \n     * @param key The object key or array index to be looked up\n     */\n    get(key: number | string): Decoder<T> {\n        if (typeof key === \"number\") {\n            return this.index(key)\n        }\n        return this.field(key)\n    }\n\n    /**\n     * Decode a nested JSON object, requiring certain fields.\n     *     \n     *     const json = `{ \"person\": { \"name\": \"tom\", \"age\": 42 } }`\n     *     \n     *     string.at([\"person\", \"name\"]).decodeString(json) // \"tom\"\n     *     number.at([\"person\", \"age\"]).decodeString(json) // 42\n     * \n     * This is really just a shorthand for saying things like:\n     *     \n     *     string.field(\"name\").field(\"person\") // string.at([\"person\",\"name\"])\n     *     \n     * @param key The array of object keys or array indexes to be looked up\n     * @param d The decoder to use on each value\n     * \n     * See also the {@link at} function (this is the `at` method)\n     */\n    at(keys: (number | string)[]): Decoder<T> {\n        const d = this\n        return new Decoder(function at(v) {\n            // uglier than `for i of keys`, but having an index lets us easily build `error.path`\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i]\n                const res = value.get(key).decoderFn(v)\n                if (res.success) {\n                    v = res.value\n                }\n                else {\n                    res.error.path = [...keys.slice(0, i), ...res.error.path]\n                    return res\n                }\n            }\n            const res = d.decoderFn(v)\n            if (!res.success) {\n                res.error.path = [...Array.from(keys), ...res.error.path]\n            }\n            return res\n        })\n    }\n}\n\n/**\n * Decode a JSON string into a Typescript string.\n * \n *     string.decodeString(\"true\") // throws ParseError\n *     string.decodeString(\"42\") // throws ParseError\n *     string.decodeString(\"3.14\") // throws ParseError\n *     string.decodeString(\"\\\"hello\\\"\") // \"hello\": string\n *     string.decodeString(\"{ \\\"hello\\\": 42}\") // throws ParseError\n *     string.decodeString(\"null\") // throws ParseError\n */\nexport const string = new Decoder<string>(\n    function string(v) {\n        if (typeof v === \"string\") {\n            return ok(v)\n        }\n        return error.expecting('a STRING', v)\n    })\n\n/**\n * Decode a JSON number into a Typescript number.\n * \n *     number.decodeString(\"true\") // throws ParseError\n *     number.decodeString(\"42\") // 42: number\n *     number.decodeString(\"3.14\") // 3.14: number\n *     number.decodeString(\"\\\"hello\\\"\") // throws ParseError\n *     number.decodeString(\"{ \\\"hello\\\": 42}\") // throws ParseError\n *     number.decodeString(\"null\") // throws ParseError\n */\nexport const number = new Decoder<number>(\n    function number(v) {\n        if (typeof v === \"number\") {\n            return ok(v)\n        }\n        return error.expecting('a NUMBER', v)\n    })\n\n/**\n * Decode a JSON boolean into a Typescript boolean.\n * \n *     boolean.decodeString(\"true\") // true: boolean\n *     boolean.decodeString(\"42\") // throws ParseError\n *     boolean.decodeString(\"3.14\") // throws ParseError\n *     boolean.decodeString(\"\\\"hello\\\"\") // throws ParseError\n *     boolean.decodeString(\"{ \\\"hello\\\": 42}\") // throws ParseError\n *     boolean.decodeString(\"null\") // throws ParseError\n */\nexport const boolean = new Decoder<boolean>(\n    function boolean(v) {\n        if (typeof v === \"boolean\") {\n            return ok(v)\n        }\n        return error.expecting('a BOOLEAN', v)\n    })\n\n/**\n * Decode a JSON null into a Typescript null.\n * \n *     null_.decodeString(\"true\") // throws ParseError\n *     null_.decodeString(\"42\") // throws ParseError\n *     null_.decodeString(\"3.14\") // throws ParseError\n *     null_.decodeString(\"\\\"hello\\\"\") // throws ParseError\n *     null_.decodeString(\"{ \\\"hello\\\": 42}\") // throws ParseError\n *     null_.decodeString(\"null\") // null\n */\nexport const null_ = new Decoder<null>(\n    function null_(v) {\n        if (v === null) {\n            return ok(v)\n        }\n        return error.expecting('a NULL', v)\n    })\n\n/**\n * Decode a JSON null into a Typescript constant value.\n * \n *     nullAs(42).decodeString(\"true\") // throws ParseError\n *     nullAs(42).decodeString(\"null\") // 42\n */\nexport function nullAs<T>(default_: T): Decoder<T> {\n    return null_.map(() => default_)\n}\n\n/**\n * Do not do anything with a JSON value, just bring it into Typescript as a\n * Value. This can be useful if you have particularly complex data that you\n * would like to deal with later, or if you do not care about its structure.\n */\nexport const value = new Decoder<Value>(ok)\n\n/**\n * Try a bunch of different decoders.\n * \n * This can be useful if the JSON may come in a couple different formats.\n * For example, say you want to read an array of numbers, but some of them are\n * null.\n *     \n *     const badInt: Decoder<number> = oneOf(number, nullAs(0))\n *     \n *     array(badInt).decodeString(\"[1,2,null,4]\") // [1,2,0,4]\n * \n * Why would someone generate JSON like this? Questions like this are not good\n * for your health. The point is that you can use oneOf to handle situations\n * like this!\n *     \n * You could also use oneOf to help version your data. Try the latest format,\n * then a few older ones that you still support. You could use {@link andThen}\n * to be even more particular if you wanted.\n */\nexport function oneOf<T>(head: Decoder<T>, ...tail: Decoder<T>[]): Decoder<T> {\n    return new Decoder(function oneOf(v) {\n        const errors = []\n        for (let decoder of [head, ...tail]) {\n            const res = decoder['decoderFn'](v)\n            if (res.success) {\n                return res\n            }\n            errors.push(res.error)\n        }\n        return error.oneOf(errors)\n    })\n}\n\nfunction maybe<T>(decoder: Decoder<T>): Decoder<T | null>\nfunction maybe<T, D>(decoder: Decoder<T>, default_: D): Decoder<T | D>\nfunction maybe<T>(decoder: Decoder<T>, default_?: any): Decoder<T | any> {\n    return oneOf(decoder, succeed(default_ ?? null))\n}\n\n/**\n * Ignore the JSON and produce a certain Elm value.\n * \n *     succeed(42).decodeString(\"true\") // 42\n *     succeed(42).decodeString(\"[1,2,3]\") // 42\n *     succeed(42).decodeString(\"hello\") // throws ParseError - this is not a valid JSON string\n * \n * This is handy when used with oneOf or andThen.\n */\nexport function succeed<T>(value: T): Decoder<T> {\n    return new Decoder(() => ok(value))\n}\n\n/**\n * Ignore the JSON and make the decoder fail. This is handy when used with `oneOf` or `andThen` where you want to give a custom error message in some case.\n * \n * See {@link Decoder#andThen} for an example.\n */\nexport function fail<T>(message: string): Decoder<T> {\n    return new Decoder((value: Value) => error.failure(message, value))\n}\n\n\n/**\n * Decode objects with many fields.\n * \n * It works with fields:\n * \n *     type Point3D = {x: number, y: number, z: number}\n *     const point3d: Decoder<Point3D> = combine({\n *       x: number.field(x),\n *       y: number.field(y),\n *       z: number.field(z),\n *     })\n *\n * or with tuples/arrays:\n * \n *     type Point3D = [number, number, number]\n *     const point3d: Decoder<Point3D> = combine([\n *       number.index(0),\n *       number.index(1),\n *       number.index(2),\n *     ])\n * \n * Combined fields may use a different structure than the original json:\n * \n *     type Point3D = {x: number, y: number, z: number}\n *     const point3d: Decoder<Point3D> = combine({\n *       x: number.field(a),\n *       y: number.field(b),\n *       z: number.field(c),\n *     })\n */\nexport function combine<O extends { [s: string]: unknown }>(fields: DecoderFields<O>): Decoder<O>\nexport function combine<O extends unknown[]>(tuple: DecoderTuple<O>): Decoder<O>\n// There's some very fancypants static-typing here. More info:\n// https://www.typescriptlang.org/docs/handbook/2/mapped-types.html\nexport function combine<O>(decoders: any): Decoder<any> {\n    if (Array.isArray(decoders)) {\n        return combineTuple(decoders)\n    }\n    return combineFields(decoders)\n}\ntype DecoderTuple<T extends unknown[]> = { [P in keyof T]: Decoder<T[P]> }\ntype DecoderFields<T extends { [s: string]: unknown }> = { [P in keyof T]: Decoder<T[P]> }\n\nfunction combineTuple<O extends unknown[]>(decoders: DecoderTuple<O>): Decoder<O> {\n    return new Decoder((v) => {\n        const items: DecodeResult<any>[] = decoders.map(d => d['decoderFn'](v))\n        const [errs, oks] = items.reduce(([errs, oks]: [DecodeError[], any[]], res: DecodeResult<any>): [DecodeError[], any[]] => {\n            if (res.success) {\n                oks.push(res.value)\n            }\n            else {\n                errs.push(res.error)\n            }\n            return [errs, oks]\n        }, [[], []])\n        if (errs.length > 0) {\n            return error.oneOf(errs)\n        }\n        return ok(oks as O)\n    })\n}\n\nfunction combineFields<O extends { [s: string]: unknown }>(fields: DecoderFields<O>): Decoder<O> {\n    const pairs = Object.entries(fields)\n    return new Decoder((json) => {\n        const items: [string, DecodeResult<any>][] = pairs.map(([k, d]) => [k, d.decoderFn(json)])\n        const [errs, oks] = items.reduce(([errs, oks]: [DecodeError[], [string, any][]], [key, res]: [string, DecodeResult<any>]): [DecodeError[], [string, any][]] => {\n            if (res.success) {\n                oks.push([key, res.value])\n            }\n            else {\n                res.error.path = [key, ...res.error.path]\n                errs.push(res.error)\n            }\n            return [errs, oks]\n        }, [[], []])\n        if (errs.length > 0) {\n            return error.oneOf(errs)\n        }\n        return ok(Object.fromEntries(oks) as O)\n    })\n}\n\n/**\n * Decode a date as milliseconds since the unix epoch.\n * \n *     import * as Encode from './encode'\n * \n *     const now = new Date()\n *     const encoded = Encode.date(now)\n *     date.decodeValue(encoded) === now\n */\nexport const date: Decoder<Date> = number.map(ms => new Date(ms))"],"names":[],"version":3,"file":"module.js.map"}